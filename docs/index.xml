<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>欢迎来到 Pi4J on Pi4J</title>
    <link>https://pi4j.com/</link>
    <description>Recent content in 欢迎来到 Pi4J on Pi4J</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="https://pi4j.com/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>早期版本 (V.1)</title>
      <link>https://pi4j.com/about/previous-version-v1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://pi4j.com/about/previous-version-v1/</guid>
      <description>1.X 版本文档 Pi4J 1.4 版本  发行于 2021-03-03 支持 JDK/JRE 11 和 64-bit ARM 架构平台 这是 Pi4J 1.x 的最后一个版本 Pi4J 项目现在将重点放在使用 Java 程序访问、控制 Raspberry Pi 平台的核心 I/O 以及功能的通信上 项目更新到 Apache 2.0 许可 移除了 pi4j-device 和 pi4j-gpio-extension 模块 将不再支持 Odroid、BananaPi、BPi、NanoPi、OrangePi 平台 改进和修复内容可以在这里查看： GitHub Issues (v1.4) 提前引入了 Java-modules 这也将是 V.2 版本的一部分 Documentation website V1.4  Pi4J 1.3 版本  发布于 2021-01-29 对 Pi 4B, 400, 和 Compute Module 4 提供了支持 改进和修复内容可以在这里查看： GitHub Issues (v1.</description>
    </item>
    
    <item>
      <title>直接下载</title>
      <link>https://pi4j.com/architecture/about-the-code/download/direct-download/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://pi4j.com/architecture/about-the-code/download/direct-download/</guid>
      <description>目前不支持直接下载
请根据 GitHub 源码在本地构建 或者从 Maven SNAPSHOT 仓库 获取编译好的版本</description>
    </item>
    
    <item>
      <title>Build Instructions</title>
      <link>https://pi4j.com/architecture/about-the-code/build-instructions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://pi4j.com/architecture/about-the-code/build-instructions/</guid>
      <description>Building the Pi4J Project is simple and requires minimal effort. Pi4J is primarily built using Apache Maven and Java 11. Pi4J can be built directly on your host computer or inside a Docker container where all toolchains and dependencies are already installed, configuired and cached.
If you wish to build using a Docker container, please skip ahead to the Building with Docker topic.
  Prerequsites In order to build Pi4J, the host system must have the following toolchains pre-installed.</description>
    </item>
    
    <item>
      <title>Maven 仓库</title>
      <link>https://pi4j.com/architecture/about-the-code/download/repository/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://pi4j.com/architecture/about-the-code/download/repository/</guid>
      <description>Pi4J V.2 尚未发布或发布到 Maven Central。
请根据 GitHub 源码在本地构建 或者从 Maven SNAPSHOT 仓库 获取编译好的版本</description>
    </item>
    
    <item>
      <title>新特性 (V.2)</title>
      <link>https://pi4j.com/about/new-in-v2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://pi4j.com/about/new-in-v2/</guid>
      <description>2.0 新特性 Pi4J 2.0 版本带来了许多新功能，以及一个全新的体系结构，它将专注于可扩展性、简化的集成和先进的 Java API，主要有以下内容：
 流畅的 API 接口 可控的上下文环境 可扩展的插件架构体系 用于创建新 I/O 实例的生成器模式 完善的文档，和源代码 硬件 PWM 支持 Java 11  未来计划：
 通过 Pi4J 注解进行依赖注入 支持远程 I/O（通过TCP/IP）  除了上面列出的功能外，Pi4J 2.0 版本还放弃了旧的 WiringPi 引脚编号方案，转而采用更为传统和常用的 Broadcom 引脚编号方案。多年来，这种引脚编号方案一直比较混乱，对于初学者来说经常摸不到头脑。并且由于新的 Raspberry Pi 型号引入了新的 GPIO 引脚，以至于维护起来有些麻烦。今后，Pi4J将只使用 Broadcom（BCM）的引脚编号方案。
WiringPi 项目现在已经废弃 (详情请查看： wiringpi.com/wiringpi-deprecated/)。Pi4J 2.0 版本将不再基于WiringPi，而是在内部使用 PIGPIO (http://abyz.me.uk/rpi/pigpio/) 库进行底层集成。通过这次迁移，运用 PIGPIO 守护进程，我们还将支持远程 I/O 特性（通过 TCP 连接）
和 V.1 版本对比有什么不同 从 Pi4J 2.0 版本开始构建以来，Pi4J 项目将重点放在了用 Java 程序，控制和访问树莓派平台的核心 I/O 。在 Pi4J 的早期版本中，在项目范围上过于宽泛，导致项目严重膨胀，以至于项目难以维护。现在的目标转移到树莓派底层的 I/O 功能范围内，并将更快的响应 bug 的修复，以及新平台的引入。新的项目范围通过降低访问底层 I/O 复杂性，更好的额服务于 Java 社区。</description>
    </item>
    
    <item>
      <title>设置一个新的树莓派</title>
      <link>https://pi4j.com/getting-started/set-up-a-new-raspberry-pi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://pi4j.com/getting-started/set-up-a-new-raspberry-pi/</guid>
      <description>介绍 Raspberry Pi 是一款功能强大的机器，有很多的使用示例。这很大程度上是基于您使用的操作系统，对于我们的“入门”示例，使用的是“官方 RaspberryPi OS”（以前称为“Raspbian OS”）。还有其他很多可玩性，例如在 GitHub 上的“Awesome Raspberry Pi”列表.
在本文中，我们从全新的 Raspberry Pi 开发板开始。
一步步来 第一步：当然是从盒子里将新的树莓派取出来 :-)
仔细看看，你手里拿着的才是真正的杰作。技术工程的奇迹，完美结合了强大而廉价的组件。
但要注意！这也是一些敏感的电子产品。首先触摸电源插座的接地引脚始，以确保您的身体没有静电，如果有静电可能会损坏板子。
TODO 添加图片。
材料清单  Raspberry Pi 内存卡，最低 16 GB 电脑（或者其他的树莓派） 带有 SD 卡插槽的 PC（或其他树莓派）（也许您需要一个 SD 卡适配器） 电源（5V，2A 或者 3A） 显示器、键盘、鼠标  SD card SD 卡将保存操作系统。在 Raspberry Pi 官网上，下载页面，找到 Imager 工具。选择适合您电脑的版本，下载并安装。
启动 Imager 工具并按照以下步骤操作：
 点击“操作系统”&amp;gt;“选择操作系统” 选择“树莓派操作系统（其他）” 选择“Raspberry Pi OS Full (32-bit)”                                           通过选择“完整”版本，我们将拥有一个预装了大量附加工具的操作系统，包括“OpenJDK 11”，因此将能够快速开始 Java 开发。</description>
    </item>
    
    <item>
      <title>了解 GPIO 引脚</title>
      <link>https://pi4j.com/getting-started/understanding-the-pins/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://pi4j.com/getting-started/understanding-the-pins/</guid>
      <description>将电子元件连接到 Pi 是通过连接接头中的一个或多个引脚完成的。引脚的数量随着 Raspberry Pi 板版本增长而“增长”，现在最新版本固定在 40 个引脚。需要注意的是引脚的编号，以免以错误的方式连接到组件。
引脚类型 引脚有不同的用途
电源和地 5V 和 3.3V 均可用作电源引脚，接地引脚也是电源引脚。当电路板通电以后，外围组件都可以使用引脚提供的电源。但是不能连接电流大的设备，否则 Raspberry Pi 将没法正常运行，并且会将系统重启。
数字输入输出接口 除了电源引脚，其他的都是“通用输入/输出”（GPIO）引脚。这些引脚可以通过软件寻址以用作应用程序的输入或输出。它们使用 3.3V，这意味着输出引脚将设置为 0V（低电平）或 3.3V（高电平），输入引脚将读取 0V 为低电平，3.3V 为高电平。
大多数 GPIO 引脚都有一个内部上拉或下拉电阻，可以通过软件启用。
概述 下图概述了典型 40 引脚接头的引脚和类型。注意使用的不同数字
 PIN：引脚的 1 到 40 个逻辑顺序 BCM：Java 代码中用于指定要使用的 GPIO 的数字。 BCM指的是“Broadcom SOC通道”编号，是树莓派上使用的芯片内部编号。这些数字在不同的树莓派版本之间是不同的，例如在早期的板子上 26 号针脚作用不同，或者是顺序不同。 WPI：Pi4J 的 V.1 使用的 WiringPi 编号。 WiringPi 编号有“历史原因”。在进行第一个 Raspberry Pi 的开发时，预计只有 8 个引脚编号。随着后来的设计进一步发展，WiringPi 扩展了更多的引脚。  </description>
    </item>
    
    <item>
      <title>Maven settings</title>
      <link>https://pi4j.com/architecture/about-the-code/maven-settings/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://pi4j.com/architecture/about-the-code/maven-settings/</guid>
      <description>To simplify development but not commit sensitive information, you can add personal or PC-specific settings in the Maven settings.xml file. This file is stored or needs to be created in the &amp;ldquo;.m2&amp;rdquo; directory in your home directory:
 Windows: C:\Users\YOUR_NAME.m2 Linux: /home/YOUR_NAME/.m2 Mac: /Users/YOUR_NAME/.m2  For more info see this article on Baeldung.
This is an example settings file, including settings for compiling of Pi4J and credentials to upload the generated code to a Raspberry Pi.</description>
    </item>
    
    <item>
      <title>Pin numbering</title>
      <link>https://pi4j.com/documentation/pin-numbering/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://pi4j.com/documentation/pin-numbering/</guid>
      <description>Pi4J V.1 took a pretty opinionated approach to pin numbering as the scheme was based on the underlying WiringPi. This scheme was incompatibility with other pin diagrams and pin numbering used by other development platforms and libraries.
As Pi4J V.2 is build as a &amp;ldquo;pass thru library&amp;rdquo;, and uses PiGpio as the underlying framework, the more well-known BCM numbering is being used now.
This drawing shows the different numbers for WiringPi and BCM in a 40-pins Raspberry Pi header:</description>
    </item>
    
    <item>
      <title>使用 VSC 进行 Java 开发</title>
      <link>https://pi4j.com/getting-started/java-development-on-the-raspberry-pi-with-vsc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://pi4j.com/getting-started/java-development-on-the-raspberry-pi-with-vsc/</guid>
      <description>在树莓派上使用 Java Pi4J V2 需要在 Java 11 或更新版本下运行。幸运的是，在 2019-06-20 发布的树莓派系统中，已经包含了 OpenJDK Java 11，可以在发行说明中看到：
2019-06-20: Based on Debian Buster Oracle Java 7 and 8 replaced with OpenJDK 11 但是需要注意的是这个版本仅与 ARMv7 或更高版本兼容并且不支持所有 Raspberry Pi 开发板。如果您有 Raspberry Pi A（版本 3）、B（版本 2 或更高版本）或 Compute（版本 3 或更高版本），那么您就可以开始使用了！对于其他开发板，可以在需要在 &amp;ldquo;Java for ARMv6/7/8&amp;rdquo; 中找到响应的帮助。
如果您准备了一张带有最新版本 Raspberry Pi 系统（完整版）的 microSD 卡，安装步骤在 &amp;ldquo;设置新的 Raspberry Pi&amp;rdquo;，启动树莓派，可以在终端查看安装的 Java 版本。在带有 ARMv7 或 ARMv8 的板上，您将得到以下结果：
$ java -version openjdk version &amp;quot;11.0.3&amp;quot; 2019-04-16 OpenJDK Runtime Environment (build 11.</description>
    </item>
    
    <item>
      <title>发行说明</title>
      <link>https://pi4j.com/about/release-notes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://pi4j.com/about/release-notes/</guid>
      <description>2021-08-26 2.0 它来了它来了！经过大量工作，现在我们向你汇报 Pi4J 库的成果！
2.0 版本的重要变更：
 支持 Java 11 或者更高 打破 V1 版本的架构，进行了完全的重构（详情请参考： pi4j.com/architecture） 不再包含外围设备的支持逻辑，附加芯片组/板的逻辑被抽离出核心模块 更易于扩展、测试和维护 使用 PiGpio 作为原生库（在 V1 版本中使用的是 WiringPi 在 2019 年被弃用） 模块化的构建，完全支持 Java 的未来发展 少量的外部依赖（仅仅使用到 SLF4J） 不同的场景示例代码（还有 JavaFX）详情请参考： pi4j.com/getting-started 更多请参考：pi4j.com/about/new-in-v2  </description>
    </item>
    
    <item>
      <title>安装</title>
      <link>https://pi4j.com/architecture/about-the-code/download/install/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://pi4j.com/architecture/about-the-code/download/install/</guid>
      <description>该项目仍在开发中，因此目前没有可用的软件包安装程序。</description>
    </item>
    
    <item>
      <title>在远程 PC 上进行开发</title>
      <link>https://pi4j.com/getting-started/developing-on-a-remote-pc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://pi4j.com/getting-started/developing-on-a-remote-pc/</guid>
      <description>GITHUB 项目地址： https://github.com/Pi4J/pi4j-maven-archetype
 使用远程 PC 工作站开发 Java 程序 直接在 Raspberry Pi 板上编写您的 Java 程序，编译并运行它，像前一章说的那样，完全没问题。我们还可以使用普通台式计算机作为远程开发工作站（RDW）。
这个 Maven Archetype会给你一个工具来生成Pi4J-V2骨架Java项目。你可以将它用于你的下一个 Pi4j 项目，你可以在远程工作站 (RDW) 上开发你的程序，编译它们，在目标 Pi 板上传输可执行代码并运行它。同样还可以启动远程调试。
使用这样的开发模式，会有一些优点和缺点：
 优点：  与 Raspberry Pi 相比，您的 RDW 拥有更强的能力，例如内存、磁盘容量和 CPU 功率，这对于 P4 型号也是如此。您可以将所有程序存储在台式计算机中。 您不必在 Raspberry Pi 上安装 Visual Studio Code（或者其他的 IDE 程序）、不用安装 Java JDK（JRE 就足够了）、以及 Maven 和其他开发工具。而且不需要将屏幕、键盘和鼠标连接到 Raspberry Pi 可以使用小的 PI 型号   缺点：  你不能运行 Web 项目（使用 web 容器，例如 Tomcat 或者 similar）    设置 为树莓派配置无界面模式 无界面模式可以使树莓派通过 SSH 协议连接 RDW（远程工作站）</description>
    </item>
    
    <item>
      <title>Code styling</title>
      <link>https://pi4j.com/architecture/about-the-code/code-styling/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://pi4j.com/architecture/about-the-code/code-styling/</guid>
      <description>To prevent unnecessary code (tabs versus spaces, number of characters per line&amp;hellip;) we have defined an editorconfig for IntelliJ IDEA. You can find more info here about its use.
Some tips to keep the code clean and readable:
 Short methods with a clear name Use SonarLint to get improvement tips while code Use shortcuts  CTRL+ALT+L: Reformat code CTRL+ALT+O: Optimize imports    </description>
    </item>
    
    <item>
      <title>Hardware testing</title>
      <link>https://pi4j.com/architecture/about-the-code/hardware-testing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://pi4j.com/architecture/about-the-code/hardware-testing/</guid>
      <description>This is an experimental project which will need a lot of love&amp;hellip; The new Raspberry Pi Pico with a lot of GPIOs for a very low price, seems even to be a better fit for this project compared to the Arduino Due&amp;hellip; To be further investigated!
 To minimize the required time and efforts to test a new release, V.2 aims to include an automated test which performs I/O testing on each I/O interface on each model of RPi.</description>
    </item>
    
    <item>
      <title>Java for ARMv6/7/8</title>
      <link>https://pi4j.com/documentation/java-installation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://pi4j.com/documentation/java-installation/</guid>
      <description>Raspberry Pi OS Full comes with Java 11 pre-installed. But this version only works on board-versions with an ARMv7 or ARMv8. In some cases you will need to do some additional steps to install a Java version which works on your board.
 Board versions With ARMv6 processor  Raspberry Pi 1 A and A+ Raspberry Pi 1 B and B+ Compute Module 1 Zero 1.2, 1.3 and W  With ARMv7 or ARMv8 processor  Model A+, version 3 Model B, version 2, 3 and 4 Compute Module, version 3  How to check and install Java Check the current version If you prepared a microSD card with the latest version of Raspbian OS (full version), Java is already installed!</description>
    </item>
    
    <item>
      <title>开源证书</title>
      <link>https://pi4j.com/about/license/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://pi4j.com/about/license/</guid>
      <description>Pi4J 2.0 版本是基于Apache 2.0 证书（商业友好的 OSS 证书）
 apache.org/licenses/LICENSE-2.0 github.com/Pi4J/pi4j-v2/blob/master/LICENSE.txt   Apache License Version 2.0, January 2004 http://www.apache.org/licenses/ TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
  Definitions.
&amp;ldquo;License&amp;rdquo; shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document.
&amp;ldquo;Licensor&amp;rdquo; shall mean the copyright owner or entity authorized by the copyright owner that is granting the License.</description>
    </item>
    
    <item>
      <title>最小示例程序</title>
      <link>https://pi4j.com/getting-started/minimal-example-application/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://pi4j.com/getting-started/minimal-example-application/</guid>
      <description>GITHUB 项目地址： https://github.com/Pi4J/pi4j-example-minimal
 &amp;ldquo;pi4j-example-minimal&amp;rdquo; GitHub 项目 包含使用 Pi4J 控制数字输入和输出的示例小程序。本章会详细解释这个项目。这个程序会打开/关闭 LED，每次按下按钮时，闪烁频率会加大。按下第 5 次的时候，应用程序将停止。
  接线 这个示例程序接线如下图所示：
构建程序 Pi4J 项目使用到的最主要的构建工具就是 Maven，但是在这个示例中我们提供了 Maven 和 Gradle 两种构建方式，你可以根据你的情况进行选择性使用。
Maven 这个示例程序可以使用 Apache Maven 3.6（或者更高版本）Java 11 OpenJDK（或者更高版本）如前几页所述。必须在构建此项目之前安装这些工具。可以使用以下命令下载所有项目依赖并编译Java模块。您可以使用 Java 11+ 直接在 Raspberry Pi 上构建此项目。
mvn clean package Gradle 您还可以使用 Gradle 6.6（或更高版本）和 Java 11 OpenJDK（或更高版本）。 Gradle 包装器的使用方法参考 docs.gradle.org。 Gradle 配置文件参考 build.gradle-file
Linux 系统:
./gradlew build Windows 系统:
gradlew.bat build pom.xml 依赖 对 Maven 项目来说，pom.xml 中定义了项目的所有依赖，以及构建流程。 在本项目中，我们使用了 slf4 来打印日志， pi4j-core 和 pi4j-plugins 来控制树莓派 GPIO 为了方便版本升级，我们添加了版本的配置文件。</description>
    </item>
    
    <item>
      <title>Soft real time PLC with Strolch</title>
      <link>https://pi4j.com/featured-projects/soft-real-time-plc-written-in-strolch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://pi4j.com/featured-projects/soft-real-time-plc-written-in-strolch/</guid>
      <description>Strolch is a framework for developing Software which has a different approach compared to Spring and other similar types of Java frameworks, as the model is defined as an abstract model, where you always have the same three types of objects: Resources, Orders and Activities. The fields are mapped as Parameter objects, of which the important primitives are available.
    Conveyors for containers filled by a dispensing robot</description>
    </item>
    
    <item>
      <title>Logging with SLF4J</title>
      <link>https://pi4j.com/documentation/logging/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://pi4j.com/documentation/logging/</guid>
      <description>Pi4J uses SLF4J for logging. To include it in your project, add this Maven dependency:
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;slf4j-simple&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.0.0-alpha0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; There are different ways to configure the logging output, as described on the SLF4J website, but the shortest is probably with this property in your main-method:
public static void main(String[] args) throws Exception { // Configure default lolling level, accept a log level as the first program argument  System.setProperty(&amp;#34;org.slf4j.simpleLogger.defaultLogLevel&amp;#34;, &amp;#34;INFO&amp;#34;); // Your code comes here } </description>
    </item>
    
    <item>
      <title>PiJukeBox by Daniel Mårtensson</title>
      <link>https://pi4j.com/featured-projects/pijukebox-by-daniel-martensson/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://pi4j.com/featured-projects/pijukebox-by-daniel-martensson/</guid>
      <description>Daniel used Java and Pi4J to turn an old Centrum U68 from 1940 into a MP3 player. The reason is because short wave, middle wave and long wave is today obsolete and not being used or sended today in Sweden. Also the electronics inside was a mess and very dangerous because it runs on both AC/DC current and all the wires began to lose their isolators.
Features: autoplaying next song, 60 songs included, volume tuning, song select, low power consumption, works with old Raspberry Pi&amp;rsquo;s, terminal based.</description>
    </item>
    
    <item>
      <title>团队</title>
      <link>https://pi4j.com/about/team/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://pi4j.com/about/team/</guid>
      <description>Robert Savage, Project Founder, Architect, Lead Developer. Principal Software Architect/Engineer. Consultant, technology enthusiast, entrepreneur, open source contributor, technology blogger. Founder at shadeBlue, LLC and SavageSoftware, LLC. Robert has a more than 20 year career working in the professional audio visual and home/commercial automation industry and an extensive background in developing technology solutions with a special focus on home automation and hardware/firmware/software integration.</description>
    </item>
    
    <item>
      <title>CrowPi OS</title>
      <link>https://pi4j.com/getting-started/crowpi/crowpi-os/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://pi4j.com/getting-started/crowpi/crowpi-os/</guid>
      <description>You can start experimenting with the default Raspberry Pi OS, but to make things easier a prepackaged OS is available with additional tools. Follow these steps to get started quickly with this CrowPi OS.
Install the Raspberry Pi Imager The official Imager Tool can be downloaded directly from the Raspberry Pi website. This simple tool works on all common operating systems and can be installed very easily with just a few keystrokes.</description>
    </item>
    
    <item>
      <title>Develop with Intellij IDEA</title>
      <link>https://pi4j.com/getting-started/crowpi/develop-with-intellij/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://pi4j.com/getting-started/crowpi/develop-with-intellij/</guid>
      <description>In this tutorial, IntelliJ IDEA is used for the development. The articles, instructions and pictures are created accordingly. IntelliJ IDEA is from available Jetbrains in different versions. The community version has enough functionality for development with the CrowPi and is available for Windows, MacOS and Linux, but NOT for Raspberry Pi. The download can be found here.
The subsequent setup of IntelliJ IDEA is identical on all platforms.
Clone the repository As soon as we have installed the development environment, it is time to clone the entry-level project for the CrowPi.</description>
    </item>
    
    <item>
      <title>Creating a Pi4J Context</title>
      <link>https://pi4j.com/documentation/create-context/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://pi4j.com/documentation/create-context/</guid>
      <description>The context is an immutable runtime object that holds the configured state and manages the lifecycle of a Pi4J instance. It includes all loaded plugins, providers, platforms, I/O instance registry, environmental configuration and runtime objects including executor thread pools, I/O event listeners, etc.
Terminating/destroying the context stops and releases all resources, threads, listeners, and provisioned I/O instances held by the context.
Version 1 was implemented using a static singleton, while version 2 uses a &amp;ldquo;Context&amp;rdquo; to avoid static singletons.</description>
    </item>
    
    <item>
      <title>User interface with JavaFX</title>
      <link>https://pi4j.com/getting-started/user-interface-with-javafx/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://pi4j.com/getting-started/user-interface-with-javafx/</guid>
      <description>GITHUB PROJECT: https://github.com/Pi4J/pi4j-example-javafx
 JavaFX is a framework to create user interfaces for desktop (Windows, Mac, Linux) and mobile phones. JavaFX is an opensource project which is documented on openjfx.io and the sources are available in this GitHub project.
The main goal of Java has always been to be able to create applications which are &amp;ldquo;write once, run everywhere&amp;rdquo;. JavaFX promises the same for Graphical User Interface applications.
Gluon is the main maintainer of the OpenJFX project and offers commercial support to companies who want to use JavaFX in critical applications.</description>
    </item>
    
    <item>
      <title>FXGl to Picade</title>
      <link>https://pi4j.com/getting-started/fxgl/fxgl-to-picade/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://pi4j.com/getting-started/fxgl/fxgl-to-picade/</guid>
      <description>GITHUB PROJECT: https://github.com/Pi4J/pi4j-example-fxgl
 In this section we demonstrate how to convert existing FXGL projects to work on a RaspberryPi
If you don&amp;rsquo;t have an existing FXGL project, go grab one from FXGLGames
Steps to get your app running on a RaspberryPi  Add Maven support to your project In our project we use Maven to manage dependencies and build the application, other build tools such as gradle are also viable but not covered in this tutorial.</description>
    </item>
    
    <item>
      <title>JavaFX kiosk mode</title>
      <link>https://pi4j.com/getting-started/fxgl/kiosk-mode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://pi4j.com/getting-started/fxgl/kiosk-mode/</guid>
      <description>Visit webtechie.be for the full blogpost
 Kiosk Mode With Gluon&amp;rsquo;s JavaFX 17-ea, we are able to run applications in different modes: Desktop and Kiosk mode. In this post we focus on the Kiosk mode only.
With this approach, the application is the only thing you see on the screen. This prevents the user to open any other applications, or mess up your system. In this case, there is no need for a window manager, and the application directly uses the underlying (hardware) framebuffer.</description>
    </item>
    
    <item>
      <title>Building an I/O Instance</title>
      <link>https://pi4j.com/documentation/build-io/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://pi4j.com/documentation/build-io/</guid>
      <description>TODO</description>
    </item>
    
    <item>
      <title>Learn more...</title>
      <link>https://pi4j.com/getting-started/learn-more/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://pi4j.com/getting-started/learn-more/</guid>
      <description>Pi4J is used in a lot of projects, and you can find a lot of examples online. On this page we want to keep an up-to-date list. Do you want to add something? Please hit &amp;ldquo;Edit this page&amp;rdquo; on the top and create a pull request!
Twitter Please share your personal or professional projects where you combine Java and the Raspberry Pi on Twitter with the hashtag #JavaOnRaspberryPi.
Online articles  Foojay.</description>
    </item>
    
    <item>
      <title>Devices examples</title>
      <link>https://pi4j.com/documentation/device-examples/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://pi4j.com/documentation/device-examples/</guid>
      <description>The core Pi4J V.2 library doesn&amp;rsquo;t contain any specific support for devices like buttons, motors, LCD&amp;hellip; This was part of V.1 but made it much more difficult to maintain and fully test the library.
On this page we want to keep a list of projects which contain implementation code for specific devices using the Pi4J V.2 core library. Please let us know through the forum if you want to have your project added to this list.</description>
    </item>
    
    <item>
      <title>I/O Registry</title>
      <link>https://pi4j.com/documentation/registry/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://pi4j.com/documentation/registry/</guid>
      <description>An additional V.2 feature is an I/O registry where all I/O instances that have been created can be maintained, managed, re-accessed, etc. As the library keeps track of all the created I/O instances, they become publicly accessible through a registry where users can interrogate, iterate, identify and access all created I/O instances that Pi4J is managing.
This is very useful for add-ons/plugins that want to provide runtime information about the state of all I/O, for example a web app illustrating the current state of I/O.</description>
    </item>
    
    <item>
      <title>Shutting down the Pi4J Context</title>
      <link>https://pi4j.com/documentation/shutdown/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://pi4j.com/documentation/shutdown/</guid>
      <description>At the end of our application, the context needs to be shutdown to release the I/O and clean up the used resources.
# Start of program var pi4j = Pi4J.newAutoContext(); # YOUR CODE GOES HERE # End of program pi4j.shutdown(); </description>
    </item>
    
    <item>
      <title>Digital Output (GPIO)</title>
      <link>https://pi4j.com/documentation/io-examples/digital-output/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://pi4j.com/documentation/io-examples/digital-output/</guid>
      <description>A digital output translates a false/true (or 0/1) to an output value of 0V or 3.3V. This means you can control any type of device which works with max 3.3V to off or on. The most basic example is a LED. Always check which is the correct input voltage for your device! For a LED you will need to put a resistor with the correct value between the GPIO and the LED, you can find a lot of examples and calculators online, for example on circuitdigest.</description>
    </item>
    
    <item>
      <title>Digital Input (GPIO)</title>
      <link>https://pi4j.com/documentation/io-examples/digital-input/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://pi4j.com/documentation/io-examples/digital-input/</guid>
      <description>Similar to a digital output pin, a digital input translates an input value of 0V or 3.3V to the value false/true. This means any type of device which can toggle between 3.3V and 0V, can generate an input value to the Raspberry Pi. Here the most basic example is a toggle button. If you use other components, always check which is the voltage provided by the device. Or if you use a power pin from the Raspberry Pi itself, to use a 3.</description>
    </item>
    
    <item>
      <title>Pulse Width Modulation (PWM)</title>
      <link>https://pi4j.com/documentation/io-examples/pwm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://pi4j.com/documentation/io-examples/pwm/</guid>
      <description>What is it? The abbreviation PWM stands for &amp;ldquo;Pulse Width Modulation&amp;rdquo; and is also often referred to in German as pulse width modulation or pulse width modulation. This technology is used, among other things, to control servomotors and is also used, for example, for the fans of a regular computer.
With PWM, it is possible to control a component such as a motor no longer purely binary, i.e. off (0% power) or on (100% power), but to control them almost at will.</description>
    </item>
    
    <item>
      <title>I²C Clock Stretching</title>
      <link>https://pi4j.com/documentation/io-examples/i2c/clock-stretching/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://pi4j.com/documentation/io-examples/i2c/clock-stretching/</guid>
      <description>Clock Stretching Please be aware there are some hardware issues when using the Raspberry Pi with devices that expect to be able to use clock stretching, for more info see &amp;ldquo;Adventures in I2C: clock stretching on the Raspberry Pi&amp;rdquo; and &amp;ldquo;I2C stretch bug. Been fixed or not?&amp;quot;.
 Clock stretching in I2C allows a slave device to halt the master before a more data is sent. This is often the case when the slave device writes to an EEPROM etc.</description>
    </item>
    
    <item>
      <title>Serial Peripheral Interface (SPI)</title>
      <link>https://pi4j.com/documentation/io-examples/spi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://pi4j.com/documentation/io-examples/spi/</guid>
      <description>What is it? The Serial Peripheral Interface, abbreviated to SPI, is a bus system which enables communication between a main device (called “master”) and one or more secondary devices (called “slave”). A direct communication between all participants is not possible here, much more the master can choose at any time with which slave he would like to exchange data.
In order to address only one slave, a total of 3 signal lines are required, two of which are used for bidirectional data transmission and one as a clock generator for serial transmission.</description>
    </item>
    
    <item>
      <title>Serial (UART/RS232)</title>
      <link>https://pi4j.com/documentation/io-examples/serial/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://pi4j.com/documentation/io-examples/serial/</guid>
      <description>TODO</description>
    </item>
    
    <item>
      <title>Annotated provisioning</title>
      <link>https://pi4j.com/architecture/advanced/annotated-provisioning/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://pi4j.com/architecture/advanced/annotated-provisioning/</guid>
      <description>To simplify the initial V.2 version, the DI implementation has be removed so it could be refactored and extended later. It is still available in the branch #22-annotations
 Next to the declarative approach, Java annotations are available for the configuration of I/O provisioning instead of the hard-coded approach offered in V.1.
This implementation still needs to be further fine-tuned and unified somehow to make things cleaner and more straightforward, but would provide a way to initialize a I/O for instance like this:</description>
    </item>
    
    <item>
      <title>Dependency injection</title>
      <link>https://pi4j.com/architecture/advanced/dependency-injection/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://pi4j.com/architecture/advanced/dependency-injection/</guid>
      <description>To simplify the initial V.2 version, the DI implementation has be removed so it could be refactored and extended later. It is still available in the branch #22-annotations
 Along with the annotated I/O configuration the ability to support I/O provisioning via dependency injection also makes a lot of sense. There is some basic brute-force stuff working but this needs more work to make this a compatible implementation for Spring or CDI.</description>
    </item>
    
    <item>
      <title>LinuxFS</title>
      <link>https://pi4j.com/documentation/providers/linuxfs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://pi4j.com/documentation/providers/linuxfs/</guid>
      <description>The current implementation of the LinuxFS plugin implements a file based I2C provider. The file based provider opens /dev/i2c-1 using a RandomAccessFile to perform I2C reads and writes.
To use the LinuxFS provider first add the proper dependency:
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.pi4j&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;pi4j-plugin-linuxfs&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${pi4j.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; And then one can get access to the provider as follows:
Context pi4j = Pi4J.newAutoContext(); I2CProvider i2CProvider = pi4j.provider(&amp;#34;linuxfs-i2c&amp;#34;); I2CConfig i2cConfig = I2C.newConfigBuilder(pi4j).id(&amp;#34;TCA9534&amp;#34;).bus(1).device(0x3f).build(); try (I2C tca9534Dev = i2CProvider.</description>
    </item>
    
    <item>
      <title>Native Library Path</title>
      <link>https://pi4j.com/architecture/advanced/library-path/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://pi4j.com/architecture/advanced/library-path/</guid>
      <description>Overview Some Pi4J plugins, such as the Pi4J PiGpio Provider plugin, depend on native JNI libraries to communicate with the underlying system. By default Pi4J embeds these native libraries as resources inside the plugin&amp;rsquo;s JAR file. At runtime Pi4J extracts the native library into a temporary directory so the JVM can load the library from the filesystem. Upon termination the temporary file is automatically removed.
This automatic extration behavior works well for most users; however, there are certain edge cases where this may fail.</description>
    </item>
    
    <item>
      <title>PiGpio</title>
      <link>https://pi4j.com/documentation/providers/pigpio/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://pi4j.com/documentation/providers/pigpio/</guid>
      <description>TODO</description>
    </item>
    
    <item>
      <title>Plug-ins</title>
      <link>https://pi4j.com/architecture/advanced/plugins/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://pi4j.com/architecture/advanced/plugins/</guid>
      <description>The goal of Pi4J V.2 is to provide a solid base with all required &amp;ldquo;minimal functionality&amp;rdquo; while at the same time, promote third-party development and extensibility, thus enabling developers to build and maintain their extensions outside of the Pi4J core projects codebase.
This will enable us to deliver a stable, fully tested framework as the number of features inside of Pi4J can be limited and support for specific I/O hardware can be provided with an extension for Pi4J.</description>
    </item>
    
    <item>
      <title>Raspberry Pi</title>
      <link>https://pi4j.com/documentation/platforms/raspberry-pi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://pi4j.com/documentation/platforms/raspberry-pi/</guid>
      <description>TODO</description>
    </item>
    
    <item>
      <title>Remote support</title>
      <link>https://pi4j.com/architecture/advanced/remote-support/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://pi4j.com/architecture/advanced/remote-support/</guid>
      <description>One of the big features on the wish-list for V.2: native support for remote I/O capability. Predominantly to support the ability for a user to perform development work on their desktop/laptop and be able to run their project with remote support slaving the I/O to a daemon running on the Raspberry Pi (or other supported SBC).
TO BE DECIDED: the V.2 codebase does support this currently by using the PiGpio daemon.</description>
    </item>
    
    <item>
      <title>Third-Party Integration</title>
      <link>https://pi4j.com/architecture/advanced/3rd-party/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://pi4j.com/architecture/advanced/3rd-party/</guid>
      <description>TODO</description>
    </item>
    
  </channel>
</rss>
